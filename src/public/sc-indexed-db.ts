import { TranslateRequest } from '../types';
import type { WebpageTranslateResult } from './web-page-translate';

const DB_NAME = 'ScTranslator';
const DB_VERSION = 3;

export const DB_STORE_COLLECTION = 'collection';

export type StoreCollectionValue = {
    text: string;
    date: number;
    translations: {
        translateRequest: TranslateRequest;
        source: string;
    }[];
    note?: string;
    tags?: string[];
};

export const DB_STORE_PAGE_TRANSLATION_CACHE = 'page-translation-cache';

export type StorePageTranslationCacheValue = {
    query: string;
    key: string;
    date: number;
    translation: WebpageTranslateResult;
};

export const DB_STORE_PAGE_TRANSLATION_RULE = 'page-translation-rule';

export type StorePageTranslationRuleValue = {
    id: number;
    patterns: string;
    include?: string;
    exclude?: string;
};

type StoreName = typeof DB_STORE_COLLECTION | typeof DB_STORE_PAGE_TRANSLATION_CACHE | typeof DB_STORE_PAGE_TRANSLATION_RULE;
type StoreValue<T> = 
    T extends typeof DB_STORE_COLLECTION ? StoreCollectionValue :
    T extends typeof DB_STORE_PAGE_TRANSLATION_CACHE ? StorePageTranslationCacheValue :
    T extends typeof DB_STORE_PAGE_TRANSLATION_RULE ? StorePageTranslationRuleValue :
    never;
type StoreAddValue<T> = 
    T extends typeof DB_STORE_COLLECTION ? StoreCollectionValue :
    T extends typeof DB_STORE_PAGE_TRANSLATION_CACHE ? StorePageTranslationCacheValue :
    T extends typeof DB_STORE_PAGE_TRANSLATION_RULE ? Omit<StorePageTranslationRuleValue, 'id'> :
    never;

const scIndexedDB = (() => {
    let instance: IDBDatabase;

    const getInstance = async (): Promise<IDBDatabase> => {
        if (instance) { return instance; }

        const request = indexedDB.open(DB_NAME, DB_VERSION);

        instance = await new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
            request.onupgradeneeded = () => {
                if (!request.result.objectStoreNames.contains(DB_STORE_COLLECTION)) {
                    request.result.createObjectStore(DB_STORE_COLLECTION, { keyPath: 'text' });
                }

                if (!request.result.objectStoreNames.contains(DB_STORE_PAGE_TRANSLATION_CACHE)) {
                    const pageTranslationCacheStore = request.result.createObjectStore(DB_STORE_PAGE_TRANSLATION_CACHE, { keyPath: 'query' });
                    pageTranslationCacheStore.createIndex('date', 'date');
                    pageTranslationCacheStore.createIndex('key', 'key');
                }

                if (!request.result.objectStoreNames.contains(DB_STORE_PAGE_TRANSLATION_RULE)) {
                    request.result.createObjectStore(DB_STORE_PAGE_TRANSLATION_RULE, { keyPath: 'id', autoIncrement: true });
                }
            };
        });

        return instance;
    };

    const withStore = async (storeName: string, mode: IDBTransactionMode): Promise<[IDBObjectStore, Promise<void>]> => {
        const instance = await getInstance();
        const transaction = instance.transaction([storeName], mode);

        const done = new Promise<void>((resolve, reject) => {
            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });

        return [transaction.objectStore(storeName), done];
    };

    return {
        get: async <T extends StoreName>(storeName: T, query: IDBValidKey | IDBKeyRange): Promise<undefined | StoreValue<T>> => {
            const [store, done] = await withStore(storeName, 'readonly');

            let request = store.get(query);

            await done;

            return request.result;
        },
        getAllByQueries: async <T extends StoreName>(storeName: T, queries: (IDBValidKey | IDBKeyRange)[]): Promise<(undefined | StoreValue<T>)[]> => {
            const [store, done] = await withStore(storeName, 'readonly');

            const requests: IDBRequest<StoreValue<T>>[] = [];

            queries.forEach(query => requests.push(store.get(query)));

            await done;

            return requests.map(request => request.result);
        },
        getAll: async <T extends StoreName>(storeName: T): Promise<StoreValue<T>[]> => {
            const [store, done] = await withStore(storeName, 'readonly');

            let request = store.getAll();

            await done;

            return request.result;
        },
        getAllKeys: async <T extends StoreName>(storeName: T): Promise<IDBValidKey[]> => {
            const [store, done] = await withStore(storeName, 'readonly');

            let request = store.getAllKeys();

            await done;

            return request.result;
        },
        add: async <T extends StoreName>(storeName: T, value: StoreAddValue<T>, key?: IDBValidKey ) => {
            const [store] = await withStore(storeName, 'readwrite');

            store.put(value, key);
        },
        addAll: async <T extends StoreName>(storeName: T, values: StoreAddValue<T>[]) => {
            const [store, done] = await withStore(storeName, 'readwrite');

            values.forEach(value => store.put(value));

            await done;
        },
        delete: async <T extends StoreName>(storeName: T, query: IDBValidKey | IDBKeyRange | (IDBValidKey | IDBKeyRange)[]) => {
            const [store, done] = await withStore(storeName, 'readwrite');

            Array.isArray(query) ? query.forEach((value) => store.delete(value)) : store.delete(query);

            await done;
        },
        clear: async <T extends StoreName>(storeName: T) => {
            const [store] = await withStore(storeName, 'readwrite');

            store.clear();
        }
    }
})();

export default scIndexedDB;